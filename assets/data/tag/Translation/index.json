{"hash":"843e47f385d56c2b19388c4509fc534a1d06489c","data":{"tag":{"title":"Translation","belongsTo":{"edges":[{"node":{"title":"[번역] When CSS Blocks","path":"/when-css-blocks/","date":"30. November 2020","timeToRead":5,"description":"이 글에서는 preload를 왜 주의해서 사용해야 하는지, 또 Document 순서가 성능에 어떻게 중요한 영향을 미칠 수 있는지 필자가 경험한 실제 사례에 기반하여 설명하고자 한다","content":"<blockquote>\n<p>Tim Kadlec의 <a href=\"https://timkadlec.com/remembers/2020-02-13-when-css-blocks/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">When CSS Blocks</a> 번역글입니다. 굳이 이 글이 아니더라도 모든 번역글은 역자의 의도와 상관없이 원문의 내용과 다르게 전달될 수 있으니 원문도 같이 보시는 걸 권해드립니다.</p>\n</blockquote>\n<p>이 글에서는 <strong><em>preload</em></strong>를 왜 주의해서 사용해야 하는지, 또 Document 순서가 성능에 어떻게 중요한 영향을 미칠 수 있는지 필자가 경험한 실제 사례에 기반하여 설명하고자 한다(참고: <a href=\"https://csswizardry.com/2018/11/css-and-network-performance/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Harry Roberts가 상세하게 설명한 글</a>이 있다).</p>\n<p>필자는 <a href=\"https://www.filamentgroup.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Filament Group</a>의 열렬한 팬이다. 그들은 엄청난 양의 고품질 작업물들을 생산하여 지속적으로 웹 개선을 위한 리소스들을 제공하고 있다. <a href=\"https://github.com/filamentgroup/loadCSS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">loadCSS</a>는 그 작업물 중 하나인데, 이 프로젝트는 필자가 오랫동안 중요하지 않은 CSS를 로드하는 방법으로 권장해온 것이다.</p>\n<p><a href=\"https://www.filamentgroup.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Filament Group</a>의 작업 방향이 <a href=\"https://www.filamentgroup.com/lab/load-css-simpler/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">바뀌긴 했지만</a>, 필자는 여전히 운영 환경에서 사용하고 있다.</p>\n<p>필자가 주목한 패턴 중 하나는 <strong><em>preload/polyfill</em></strong> 패턴이다. 이 패턴에서는 스타일시트를 preload로 사전에 로드한 다음, onload 이벤트를 사용하여 브라우저가 준비되었을 때 스타일시트로 다시 돌아가 작업을 진행할 수 있다. 아래는 preload의 예시이다.</p>\n<pre><code class=\"language-html\">&#x3C;link\n  rel=\"preload\"\n  href=\"path/to/mystylesheet.css\"\n  as=\"style\"\n  onload=\"this.rel='stylesheet'\"\n>\n&#x3C;noscript>\n  &#x3C;link rel=\"stylesheet\" href=\"path/to/mystylesheet.css\">\n&#x3C;/noscript>\n</code></pre>\n<p>모든 브라우저가 preload 기능을 지원하는 것은 아니기 때문에, loadCSS는 다음과 같이 polyfill을 제공한다.</p>\n<pre><code class=\"language-html\">&#x3C;link\n  rel=\"preload\"\n  href=\"path/to/mystylesheet.css\"\n  as=\"style\"\n  onload=\"this.rel='stylesheet'\"\n>\n&#x3C;noscript>\n  &#x3C;link rel=\"stylesheet\" href=\"path/to/mystylesheet.css\">\n&#x3C;/noscript>\n&#x3C;script>\n/*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */\n(function(){ ... }());\n&#x3C;/script>\n</code></pre>\n<hr>\n<h2 id=\"네트워크-우선-순위-조정\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%EC%A1%B0%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>네트워크 우선 순위 조정</h2>\n<p>preload를 사용하면 어떤 자원이든 바로 다운로드가 가능하다. 스타일시트 같은 초기 렌더링에 그다지 중요하지 않은 자원들에 대해 preload를 사용하면 브라우저가 비동기 처리 대상으로 판단하여 매우 높은 우선순위를 가지고, 다른 자원과 상관없이 바로 다운로드가 시작된다.</p>\n<p>아래 이미지가 좋은 예시이다. 3 ~ 6번이 preload를 사용하여 비동기적으로 로드되는 CSS 파일이다. 설령 해당 CSS가 초기 렌더링을 차단할 정도로 중요하지 않다 하더라도 preload를 사용하면 사용하지 않은 자원들보다 먼저 도착한다.</p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 900 169' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6f011cb8657ab88684a07d23cf8545eb'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6f011cb8657ab88684a07d23cf8545eb)' width='900' height='169' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAMCAIAAABdkSyeAAAACXBIWXMAAAsSAAALEgHS3X78AAAE/klEQVRIx61VaY/bVBTNj%2bcrH/kACPEB1NLpgkBCVYdKZaadLOOMszneEjten5/teHe8JE7CidMOQyUqVPXJejm5frHvueeemw47eOZ7NI4TQojjOKqq2rbt%2b75pmlVVWZaltwtftXYlcZxm2Q9/XX3TZd5MmbL77ebuZ%2bfS1n9y7See%2bdg1HlHrlxY8puYjn/5OJZUMBG8oeoz4fmcEFzsruc%2b73sWr5PvL8CUbLTVLMWzTN5pjs98fml1zPB4PzWGf7o/R8YQPh9N2PNRxfdycItvttsONnpmGZlrWeDxmWXY%2bn89ms%2bl0ulgsQEOSJJ7nEcTd6%2bvr4XCIOIKyotIgpJ4bUDNZ04AGvr2O3HhNgvUHgEhIY9wijms5nmlTw6a242M3LIoIcTxW1r5%2b%2bfarP256zLti8KPPvFz9RownlLyhJFatQNV8kaN9VV6pC22laFVRF3mZpdkm2%2bR5HoZhZ3DzjBDLdT1RFJGraRpnAB2CIEDJUX5FUaAM4i1YCYK49n3UAhJtymrb7Ku6Kqpit99V249BWVdlWe6b3bbGqRPAXrUAKN3kc0sd6zIl4kbvxfrE5x1/SsIFWZDJTGNm%2bi1jvOmvXvfUy4nW1wJRcQSRFz3PW6/XRVF0hMlzxzkRQNIcxyFjQRBQcjQPCKBzkDc0AYHVaoW7AFAAPz60BJBc0zR1XX8KVNWuaaoKkRM4pf8BINhUYZnZaUrSzTrJaLox89rOC1slc95kJXsyWd6%2b5n99JVwMV1cjrcubI1O3qEux8PDOsPdUWcqGYSLLCQ4vl%2bcWQrpoocViibZBa4Eemgd3sYMniEHBKIogYpqmnw2w4pgEoRaGRhybUahHLYgjUyWcYI4kezwcMdyEl8WlR/0iL7IsT9Ikaxfq2JkwLyglKPZCllFs07TOXQ5DJ0mC/sFXQeAhiHlalmEYoIEXw0O73Q42AkCl/ws8PAN8jjwA0CGKEztJSJ67Jx1OgOJSHG5uDCUyFuS5rhtIoCzK1svH3fb08/MTOrO7JxYksSyUH05FumcpoAA0kmUZ5Z%2b26%2bbmBvHzAZzfbDZxHIMJKvHZANMvjp1grQZrDbUPAy0MVq0OuuLMBJuVyEihc2O90F1JctkxeXdrXU7NHjflBFFAKTu33ecOsTzPR%2bujT1Dy1sQCUsRrMFtH7ULqd3d38MZKVXHM97w9mrgsYSNUuPokKP8NyntQAJR1XaQpFDCzHJoD2FnmZDlRFUXgFwIvS/JyNGd5hefUiR4uFz638pUkzrI0RQE6/PgpZr3j0LOJUfizidEuLQEbfBDHDhFAAwCywB77/f49gd0OZvwEwLGHoGzXP2C7S2IvCuFjK44MXEligY%2bx1NS5rsw1W9KJtnQtzbON47bGtc/DNA6SFBpGHaZ7ARMj3Ta99yY%2btxDKj1xBDK0FVyAIDud/Bpz/Ii30AWRRFCSxFYYm3AwRsEeRlqQGLs%2bY%2bMqdrw49hSFij0gDyv05Za7YyWnYdIb9F7q%2bSpIUzY10Mf6VdiF7FB5qwM1ghZLjZcgecZzBux/6Emp8BO5v/T9wb2ugpgX77bZpH3iot1tfmxKhS8S%2bvxz6ChuorGtgJipo%2bM7t2%2b84bozxMhgM%2bv0%2bmgdzExhkMPVBERHsEKHX611dXUGH878EOgRjCkwwT78QyNrPexABpC0KA9%2bnZO1Rnpt2310PmYGlySkRQ2P%2bNx%2bxIcFyYSHwAAAAAElFTkSuQmCC' /%3e%3c/svg%3e\" width=\"900\" alt=\"image\" data-srcset=\"/blog/assets/static/loadcss-preload.82a2fbd.7c0189bd1b4292decf968fd513aeca93.png 480w, /blog/assets/static/loadcss-preload.2671d65.7c0189bd1b4292decf968fd513aeca93.png 900w\" data-sizes=\"(max-width: 900px) 100vw, 900px\" data-src=\"/blog/assets/static/loadcss-preload.2671d65.7c0189bd1b4292decf968fd513aeca93.png\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/blog/assets/static/loadcss-preload.2671d65.7c0189bd1b4292decf968fd513aeca93.png\" width=\"900\" alt=\"image\"></noscript></p>\n<hr>\n<h2 id=\"html-파서-차단\"><a href=\"#html-%ED%8C%8C%EC%84%9C-%EC%B0%A8%EB%8B%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>HTML 파서 차단</h2>\n<p>네트워크 우선 순위 문제는 대부분의 상황에서 preload를 피하는 이유이다. 하지만 아래 코드처럼 외부에서 로드하는 다른 CSS가 더 있을 경우 문제가 복잡해진다.</p>\n<pre><code class=\"language-html\">&#x3C;link rel=\"stylesheet\" href=\"path/to/main.css\">\n&#x3C;link\n  rel=\"preload\"\n  href=\"path/to/mystylesheet.css\"\n  as=\"style\"\n  onload=\"this.rel='stylesheet'\"\n>\n&#x3C;noscript>\n  &#x3C;link rel=\"stylesheet\" href=\"path/to/mystylesheet.css\">\n&#x3C;/noscript>\n&#x3C;script>\n/*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */\n(function(){ ... }());\n&#x3C;/script>\n</code></pre>\n<p>위에서 설명한대로 preload를 사용한 스타일시트는 그것이 중요하든 중요하지 않든 높은 우선 순위를 가지고 바로 다운로드를 시작하며, 이러한 동작이 브라우저의 페이지 해석에 영향을 미칠 수 있다. 다시 말하지만 <a href=\"https://csswizardry.com/2018/11/css-and-network-performance/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Harry Roberts가 이것에 대해 상세하게 설명한 글</a>이 있기 때문에 꼭 읽어보기를 추천한다.</p>\n<p>여기서 간략히 설명하자면, 일반적으로 스타일시트는 페이지의 렌더링을 차단한다. 브라우저는 페이지를 표시하기 위해 스타일시트를 요청하고 해석해야 한다. 다만 이러한 과정중에 브라우저가 HTML의 나머지 부분을 해석하는 과정을 멈추지는 않는다.</p>\n<p>반면에 스크립트(<code>&#x3C;script></code>)는 defer나 async 속성이 없는 한 파서를 차단한다. 브라우저는 스크립트가 페이지 자체 또는 페이지에 적용되는 스타일을 조작할 수 있다고 가정해야 하므로 HTML 해석을 멈추고 스크립트 실행을 우선한다. 만약 요청중인 스타일시트가 있을 경우, 앞선 정의에 의해 스크립트가 실행되기 전에 해당 스타일시트가 도착할 때까지 기다린다. 즉, 스타일시트가 더이상 렌더링만 막는 것이 아니라 HTML 해석을 막는 것이다. 이 블로킹 동작은 외부 스크립트뿐만 아니라 인라인 스크립트에도 동일하게 적용된다.</p>\n<hr>\n<h2 id=\"문제-파악하기\"><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>문제 파악하기</h2>\n<p>이를 시각화할 수 있는 가장 명확한 방법은 Chrome의 개발자 도구를 살펴보는 것이다.</p>\n<p>Chrome 개발자 도구에서 성능 패널을 사용하여 페이지 로드의 프로필을 캡처할 수 있다. (스로틀링된 네트워크 설정을 사용하면 문제를 더욱 명확하게 파악할 수 있다.)</p>\n<p>아래 테스트에서는 Fast 3G 설정을 사용하여 테스트를 실행했다. 메인 스레드 액티비티를 확대하면 HTML 파싱의 첫 번째 청크(페이지 로드 프로세스 중 약 1.7초) 동안 CSS 파일에 대한 요청이 발생하는 것을 확인할 수 있다.</p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 550 509' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-5952b1e25ee95a7bec8aed4aaefba92f'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-5952b1e25ee95a7bec8aed4aaefba92f)' width='550' height='509' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAA7CAIAAABE7huLAAAACXBIWXMAAAsSAAALEgHS3X78AAAK4klEQVRo3u2Y%2b1PU1xXAv/ER8ug00%2blUGYTdZZeV17rLY3dhgVWeu7Dgizc%2bYBeQl4CKgKDRTDo6MbHTpijgI9WmeVQnmhqbRq01v9SOQhIfSWzTzNROa/Nr/4D%2b1M/3Xvi6AkkAiWs7njlczj3f8733nnPP67vK06ait0%2bfu3D%2bgzNnzoyMjIyOjl66dOnKlSsQI/fDZM4sYE4WCV5HecpUePLd3517770jR18bHBo%2bNDj00v6Xjx577cbNW1evjVwbGdVwZPSj4OnscE4WCV5H4QbOvn/x1vXR8%2b%2bfPfnW6%2b%2bcfOv0qbfPnT198/ro9Y%2buXv/4qjoKvKHRH1%2bbNd74ZORBXp%2b8DjdQlOZrqu8/vPPwh33Dl/uG/rBz%2bHL/8OWegQu9hy72DJzvPfR76J6DF/oGL/UOXuo5eLHn5x/0DMwSdxw83zsw%2b9eD1hkjlDBTkfKcw%2bUfbj7yRXn/qfqDnzYM3g68%2bknj8J8bh/7SOHi79pU/bnjpw8rn36ndf3n93gt1P/lT64l/tRy/23L8nwLvzgjbTtxtneErk7FVXWdsa/UGnohw523%2b5ebB0XV9J9Z1D2/c/eu6F07VbB/y//jdloMjVVsHGg9cDuz7bU3XQEX7K7V7TnWe%2bNvWN7/qfOOrrW/cnSl2vXl328zfmoDbxDqSVhVQwt3uhqFtv/pH29G/Nv70SvPgzeahW5tevdYy9GnbsS9bD99uO/pFy%2bHPNx%2b53TL8WePPrrYMf955/E7XsRsdv/iy/fjf24/fmT52nrjTMRP5KbFDrCNp5clo70JDwfcTyxY7A4vsteFpDYud/sUOf3ha/SKHH1wscJHTH%2bHiUQD%2bD1P9sTmNzdtftBW2/CBl42Jn3SLHdDEivT7c6Z%2b%2b/JTICSPSAz8StKqAqoO%2bYL4ud35U3vyo3PtQJzmMeWHRngW6PFCJyAm3rlzXutvgKFUishfo81Wx6WGY0bPQMAP5KZEdOcy8KJUeU2A6%2bIzZF2b0gvN0BRFJa2padxvTKp6Iyg8zFs5oESrP9OWnRHZ8Jsa30KDSs1RgSfLalq4Xza7/QQVEzHi%2bZ/bFZVU/F1e8wOCZ0d6PhAJCB68Smb9whqd/hBQAnzIWhs1870dIgdnhYwUeK/BYgccK/L8pQC6fJj7L3kbv9OW/bpGnTYUPuAgl6NkY35MGlVYWGAqniWExNA7e%2bfoHwjBT8cLoogdcRD2MyTdP54FWlljylywriLDkfysakgv1Nq9uDD0CNcITxJnMHJe0eqKTi/RJhV8vpq3g/WaOIblIEkqM0WA06JaaTSrGGMdGSYyjOcYYazalOVJdaQ6nPcUpiHSnPd2Rmp5mV%2blxTHPaQZhiatfQYU92qsIORgTsqWNTl8BgSfgOe4rr3iN1I7nsPc69VxxKYqLF6UyLjIxasiQySqeDiIxSkdkSJioRqdcbDIbo5OQUMDsn1%2b1ebrMlpdrtaWnpySkptiQgGeRperoLZkpKKjSjRJ7k5xdkud3LrNaMzEy283i9LGK12qw2IEkThsjMzMrLy2c19ZFY2e5w8ArLQqscjpFyb3Fl1apV27dvz8vLKysra2lpqa6uDvj96zdsqKmpgaiqqsrPz9fr9dHR0SkCNm3a1NHRsWbNmvr6euQrK6vKy8v9fn9FRUVBQUGZAKbZ2dnsZbfbGaFZtqSkpLq6ZsuWLUyRaWho8Pvr1gtwOp2sjLDVal23bh2c1atXQ2zcuJFj1NbW%2bny%2boqIij8fDOmyUk5ODtVIFKEwaGxvZsqmpqaysvLKyEgk26OnpaW5urqio5J3w8HCTySQVYN1AIMDIaVCPPaDRgVewAq8zbW9vh5YKsFNGRgZ8ZFiwqWkTU3QoLS1lHbZGE8wrFcDoa9eu5RHyPMVYWIrz5OXlshcnqaurw3wogyTyqgKqc0RHM2LmSOEzAAQcRuRiY2PlVL221FT5msPhkAZgCjdZOIE8cXp6%2bvLlyzULATziiPIVbRH5ipxOAISTBaSKlTUmK/DiypUr2UJ7UTGbzTFmFWJi5P8xkFOj0QixdOlS1JBbahtPBnk%2bBNBkAv8b3poMUwprTNwsWEAxmYxgjMmkHXppEEim1GGCbsHThwkTdlQSLNZEizU%2bIRFj8wxf1wvArxiZSjm9yESSD9MgQDJjQgrKlqFrHUc/K996yOlIIT7cbndmZiaRjbcRT9AkAUJtxYoVeCF8HDExMVGKkXaKi4tR6eHfwz0Fdp75d8/Z/2x88TeZLuf27u6dO3ceOHCgu7u7o7Ozq6ursLCQ7LRt2zaYe/bs6ejo7O3tJTns27eP6d69e8kVOp0ulArUPf963QunigO7LAnx1ATSH0kXY2dmZpC5RXlSw7KkZCWXQC4jSZOPvV4v9QHzkxND7EJGQ5QJpKEwGrElbs0oXZx8ahwHaJ7InKsToElOJ%2by%2buytS%2bBOBag7OP3JLjZBZSEtKwSloQnbSgl6jNb75fpgzBViLHC/NzDYTCAnyBJKPfEJCgqYMFwI/WgCc%2bPgEVoPPiBgj/Hi4CQmIGcZBrjk3CpBVcnNz6UZkuZFgsVhooWS9oBizX1xcHPUV7ydICABqIYmIF2EywszKchMvRT5fcXEJUzIYzQXyWVlZjHRj5C46CORlJzNXOigclJClu%2bBY7ERoygMRsuwNk11xd4pra2srbR9ph4aEek40b968measSwApeK1obyCQhE%2brRwaDoGnj0CQAfyDAdMeOHXQ7c5W7FLlK7DhgaUYuHaakATwH%2b6EeCQr1SP/kKM5EkkVzn2r1YvpF%2bMjAhMAQWEEWCl5ZsXw5BGojzEgNmavqoWjOrRFwtTAIHrGZyEV6WYBlIgLUb4ZxiIiIkJ2fVqq1nCZfV8fp5a7pKoCL49AyLjE8o2b7ZcuWwcdfbQJ4Klt2eS1weIohiR/cHcPT99JdcwloG5ydpoQ5U4DTS2eQAUqQEZ24hsfD/RdwSukzBAO3j2sQEjJIoFEGi9Ky02tQlfmo4PsD98DwD602K1gR05KCxFW45LeF1q7yiHtQv%2bySbLCRIRjEt5/apnNR3ABMdMCzMQGvs2BwNfjOFQhO%2bZKlOr3RFOz9WnHguLImTAgYGQya2ENtJbAiWZ9d8Vp5LFmJtDoaLwAxHmFd/TggJttvrYSH5PNA4dLzcnNJ%2bfgutMvlIgwyMjKTbDZ5oCYBfLlWVVaS44nUDQJI8/hYaHtpVQFcmRtgdGdl5QpNqM3oIFM1Zi4tLVu9alVfX9/%2b/fv5YKeX3rVrF1OqFZERegU0b5HOIP1bBHa8xidtc1ZqlvSx4B5zQjMXAgW0iNRCcMJUC1/KkAxZCbIYyTolIzg0CpAQcRubLQlHWiaASCDBWwQQu0xhWkRR46zUBBo1BPArDk3LQN1gBYRDooPiEiB7TBo42cZwJgoWBDk%2bW0BObq5MQdXV1YQBEVJeXo5ifGE2NzdTxShzIfm2VKSvczhpb6uAuPh4TM654cOUXYP0HzIPfPVOLBZCnOgnX1HLIUJzA1qkqr4%2b7uLBv8DINk77pJLxoEWzFiEhiwEMLCnZyXEa2T%2bLA6m/zHEhmJxH8rNL05BLMAX9HBayNEovKX/kweMZRa%2bWQ1Mk/YTeGH5bW5v8WRhHZ%2bRzhK8T%2bj9iOrRFQFVA/iJL8aItldEMkSmAwxG1VLfKyspOAYH6er7C%2bC7r7%2b%2bne3uYXee3N3OSkE6iuTgEwYpKjvtBptqH3LdNCf8F22clkduAlUkAAAAASUVORK5CYII=' /%3e%3c/svg%3e\" width=\"550\" alt=\"image\" data-srcset=\"/blog/assets/static/initial-css-request.41e76af.14194920841a6e8f5fc15dc2e9b5d604.png 550w\" data-sizes=\"(max-width: 550px) 100vw, 550px\" data-src=\"/blog/assets/static/initial-css-request.41e76af.14194920841a6e8f5fc15dc2e9b5d604.png\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/blog/assets/static/initial-css-request.41e76af.14194920841a6e8f5fc15dc2e9b5d604.png\" width=\"550\" alt=\"image\"></noscript></p>\n<p>그 후 1초 정도 동안 메인 스레드가 잠잠해진다. 약간의 액티비티가(preload된 스타일시트에서 로드 이벤트가 발생하고, 브라우저의 preloader에서 더 많은 요청이 전송되는 등)가 있지만 브라우저는 HTML 해석을 완전히 중단했다.</p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 900 243' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-c8e86d28efa7a22113d1c31ae7b6ef8c'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-c8e86d28efa7a22113d1c31ae7b6ef8c)' width='900' height='243' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAARCAYAAABtu6qMAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6klEQVRYw%2b1XTUvDQBCN2GzS1KIotCBqk62xLVJBxYI3W9uk6YcVRQ%2bCCOJBz4J/wotHf4a/cNbdzTZN0zQNYkFsDmFe3kzezr4dQiI9vX0A2qnDimmBVmyBqp9DGjdBplyu2ofT/gvUnEeOFb0BqtGkl1vDoopbkK30IM0w40U%2bNhY6Cl03f9AH4%2bQSUKEBmV0L1soO5zO0LxbZ/cZ%2bl%2bfZtV5xoDG45315/Qj9XPWC74XtSWM53eVZXWr7DDaPruD98wuk%2bs0zWdpqEgW3iWzYRNZtgoy2F7XSgKQK1ogP1MjYIcjsUWzx3ERNTJyiOFvqkHzVGenogbUYL/pcLthkteyQ7vWAPxvURHiKDq%2bxiGr2SW3wSqTD9h3QDYJi2IDoRZM8enh4H%2bSHHG6DYvZEflhj%2bXTGMQrFriY9BMjsdb1extedrNfMDpj1h1D9sd4NX28%2bLrvbACl/fMtPH3G3XHf8WMHhPMcssmfpBCBvAiLqZ2EsTm%2bqjh3ojZ10Z6b%2bGOfbl2Z2iZQt9SINiMS/bYCI8eptr4dZ607ToFNAJDpy3in/BQPmgaPyklp0IkZuAQyQ%2bVvSWlwDUGJAYkBiQGJAYsBiGzD5/R8Xi38BJP4FZN83/I8154Cj8v9kAuxwHIhhtQs/Ad%2bqHROfHgWJtQAAAABJRU5ErkJggg==' /%3e%3c/svg%3e\" width=\"900\" alt=\"image\" data-srcset=\"/blog/assets/static/loadcss-quiet-main-thread.82a2fbd.a83e984d9b67eb9136bedd287f55c475.png 480w, /blog/assets/static/loadcss-quiet-main-thread.2671d65.a83e984d9b67eb9136bedd287f55c475.png 900w\" data-sizes=\"(max-width: 900px) 100vw, 900px\" data-src=\"/blog/assets/static/loadcss-quiet-main-thread.2671d65.a83e984d9b67eb9136bedd287f55c475.png\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/blog/assets/static/loadcss-quiet-main-thread.2671d65.a83e984d9b67eb9136bedd287f55c475.png\" width=\"900\" alt=\"image\"></noscript></p>\n<p>약 2.8초 후에 스타일시트가 도착하고 브라우저는 이를 해석한다. 그 후에야 인라인 스크립트가 평가되고 브라우저가 마침내 HTML 해석을 시작한다.</p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 900 96' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-64ee2ea1892b3a25e1d55dde769f01cb'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-64ee2ea1892b3a25e1d55dde769f01cb)' width='900' height='96' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAHCAIAAAA3VtxdAAAACXBIWXMAAAsSAAALEgHS3X78AAACsUlEQVQ4y2PYvWfPvn37tm7dumnDut07tx07vP/IgT1HDu49cmjf0UP7gOThA7sP799FDDq4d8fJYwe3bd/RO3fNihUrDu3beezQ3iMH9wDNOXpg95H9O7GhXRDGYRDaRSo6cmA3g3d8pVdsuVtEoVNIbuXkbb0rz3UtP9O59GTnkhNdy051LTvZt/Za/4bb/RtuQdAEGANNpG/9jclbH5RP3uETXTB9RmPz1BVNC093rTjfvuRU87yDXSsv962/07v%2bNhjdgjEQ3L716MZiWoFFfNMdBgYZVwZJJwZRWyCpH9ZlkzLDKnmGZeJUy/hJ1knTLBMmOeQscypc61SwBoKcC9fA2QiRwjWOeavcyzer%2bbWxydhM7YuLyiy0iah0iat2TWhwjCp3TmjyzJrkltbnltbvmTnRPb0fyPbImOCZMcE9fYJ7Wq9r9hynwnVOBauBpmG3ogCLoEP%2bWgYOJXcOZQ9OFU8uFS8maQcGKTsgYpSyByImaXtGaXsGSRsGCWs4YkTlQkRgglaMUg6Cmh4N9XFW1tqaVqp6NmqaVioGThpm7tqmrurGzmqmbhp2Vsaebo7uLnZuzrbO9lZe7s7WptqCksoMknYgExCmIVkhhS4CRMxAQSFrBjZFdyBiB3uDXcmDXdkThJSACOgrLyCbAxUB/YkmAlTGCRME6uJQcmPTCnV2s09MCw2JCmifUJpZlSepaiaiZiumaSemYSuqaiuuYS%2bh4SCqZiuubgdki6nZ8Cs7sit7oZmGsFQVXQTiEqDzkDyg5AFhwxFQhB1VBCKIJgLyNpIgu6Ibs2aouJZLeH5xSG6xTUhSVEU9i6wzq5IXq6Ini4IHDLkDSTYlTwiDFYdpUEuV0UXgLqG%2bB9gU3Dh0QxkkXZTtY9VcEhgE7ZRso5jl3TiIcxmpHgAASkrS3jxaEN4AAAAASUVORK5CYII=' /%3e%3c/svg%3e\" width=\"900\" alt=\"image\" data-srcset=\"/blog/assets/static/loadcss-css-arrives.82a2fbd.8293cdba5522bad22515632fe5e9dfd1.png 480w, /blog/assets/static/loadcss-css-arrives.2671d65.8293cdba5522bad22515632fe5e9dfd1.png 900w\" data-sizes=\"(max-width: 900px) 100vw, 900px\" data-src=\"/blog/assets/static/loadcss-css-arrives.2671d65.8293cdba5522bad22515632fe5e9dfd1.png\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/blog/assets/static/loadcss-css-arrives.2671d65.8293cdba5522bad22515632fe5e9dfd1.png\" width=\"900\" alt=\"image\"></noscript></p>\n<h2 id=\"firefox-예외\"><a href=\"#firefox-%EC%98%88%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Firefox 예외</h2>\n<p>이 블로킹 동작은 Chrome, Edge, Safari에 적용된다. 단, Firefox는 예외다.</p>\n<p>다른 모든 브라우저는 HTML 해석을 일시 중지하지만 lookahead parser(preloader)를 사용하여 외부 리소스를 검색하고 요청한다. 하지만 Firefox는 한 단계 더 나아가 스크립트 실행을 기다리는 동안에도 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DOM 트리를 추론하여 구축</a>한다.</p>\n<p>스크립트가 DOM을 조작하여 추론적 해석 작업을 초래하지 않는 한 Firefox가 먼저 해석을 시작할 수 있다. 물론, 스크립트가 DOM을 조작한다면 이 추론 작업은 아무 소용이 없다.</p>\n<p>흥미로운 접근 방식이며 얼마나 효과적인지 매우 궁금하지만, 현재로서는 Firefox의 성능 프로파일러에서 이를 확인할 수 없다. 프로파일러에서 이 구문 분석 작업을 다시 수행해야 하는지, 수행해야 한다면 성능 비용은 얼마인지 확인할 수 없다.</p>\n<p>하지만 Firefox 개발자 도구를 개발하는 훌륭한 개발자들과 이야기를 나눈 결과, 그들은 향후 해당 정보를 어떻게 표시할 수 있을지에 대한 흥미로운 아이디어를 가지고 있었다.</p>\n<h2 id=\"문제-해결\"><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>문제 해결</h2>\n<p>다시 돌아와서 앞선 preload가 야기하는 문제의 경우 이를 해결하기 위한 첫 번째 단계는 매우 간단하다. preload/polyfill 패턴을 버리는 것이다. 중요하지 않은 CSS를 미리 로드하는 것은 목적에 어긋나며, 현재 Filament Group에서 권장하는 대로 preload 대신 print 속성을 주어 스타일시트를 사용하도록 전환하면 polyfill을 완전히 제거할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;link\n  rel=\"preload\"\n  href=\"path/to/mystylesheet.css\"\n  media=\"print\"\n  onload=\"this.media='all'\"\n>\n</code></pre>\n<p>이제 네트워크 우선순위가 다운로드되는 자원의 실제 중요도와 훨씬 더 잘 일치하고 인라인 스크립트 블록이 제거되어 더 나은 상태로 개선되었다.</p>\n<p>필자가 겪은 문제의 경우 CSS가 요청된 후에도 HTML 문서 앞 쪽에 인라인 스크립트가 하나 더 있었다. 해당 스크립트를 DOM의 스타일시트 앞으로 옮기니 파서 차단 동작이 사라졌다. Chrome 개발자 도구의 성능 패널을 다시 살펴보면 그 차이가 명확하게 드러난다.</p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 516 112' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-b39c51c15c1216ba3579259d83ac602f'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-b39c51c15c1216ba3579259d83ac602f)' width='516' height='112' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAOCAYAAACfOxrCAAAACXBIWXMAAAsSAAALEgHS3X78AAAExElEQVRIx6WXyVIjRxCG%2b%2bKrT5gIQA2S0MYuxI7YdwnEDmIfiz048AJ45jI3X3kLR/gF/Gqj6HR9iVJuK7wM4lBR1Vmqyj%2bz/j%2br5PVnxyWVTEoikZCOjg6JRCLad3V1SSwWk6Sb6%2b3tlWg0Kt3d3fo7Wnj8zvYtlUq5Pvn6048/%2bIO5yWp%2bvSz92bEglUpKPB6X9vZ2xUHjmwaGnp4eHbOP9R/Aoc0rf/5dDg/25eHhQba2tuTg4ED29/dlaWlJx2dnZ3J9fS03Nzfy%2bPioCTGnTTrXBKQyva%2be5/mbt1%2brn/8QKVV%2bCR5uPsnPlWupVCrazs/PZXV1Ve7u7uT29lb7l5cXOT4%2b1gP5SOD1BJQef5V8flrW1zfUQblclufnZymVSrK4uCjz8/PaSMTFxYVMTEzUs98kGzQByVRaEzBTvKief/lN5ounQS47KIVCUQM/Pi7L6empTE5OKo6pqSmZnZ1V29ramgwMDPwNR7NM8BLdbxQjozSob/QPN9/3dT6dTutCmJCsSaeZBLg1r6l0rx%2bPdVVjne0Si3YFUeens7NTJYAMafgGj2FjDiwfPIS/EqAaqwVpQWGzwPnRm2YT9TkDgkabkEOtBiRenV/f7VlNpTN8B7ZHJpOp%2b8QfdnyTfBr1gB58dnCG4b2J8PL5vNIaqg0ODgrf4%2bPjMjY2po1gC4WC1gd6agWUhKZ7e3tSO80mimDiNRLp8F2wVajtfAYzMzOKZXR0VCnPGBt0Jyn4Bicy2NjYUJleXV1JsVhUnMbIdyXAAmVjgJGEXC4nIyMjCoQskxSCBhCJADDBUyQB1kjH72ZAPO67vtrf3y9DQ0MBPl2vOLCBBRsnTpIpiNjAxTw4qAdgM7a%2bOwFkDt2ZBKAT32bDMTaCNH22tbVJS0uLjpuVADXANU0Aa93eQfiqfatFndrjG2z4Nylib21t1Wb2piRgp09PtunJMGOcrKysKN3IPtSDDVBud3dXstnsv57%2bfwCpM8AVM99pucotMz09HXCinDC0R4bgwgcBHx4euptqXba3txUPp355ealXdvhq/l4cZvecY%2bdoSnUG1Qge5wQKAwC3ubmpNpzzTVJ4GyAJTi2svf%2b7GZy9ngC3VosgPt1eAdJjPUGbBJEEtuXl5XpisNEjQ5olIMyAxkfbPz3i6D27XhqvPbt6oJfJhKpv8mDMdcQm4TXYTE5mC1%2btYQm4se/6auzt%2bgtMdubbGnauRLsCbS97tTaerEmmMSn2qgwzxrMs08i8FZyFhQXNOEyoUVQrM7RkDjpSgJAMhZGXI48lCiNrAMfeSAX68no7OTmhwH2rsaQugQVHZ7ePFsHh4WFdxzXX19enlR5pcANZwcM/PmEmD7elpWWVKKzEhz3oWM8%2b4EK%2bzIMHNpl0PYIkOEAzAQAm7BnM6%2b/%2b/t49Re90MfojIJ6mbMianZ0dBcdTmScsYEkkNCVwfkd7enoCUD0BYQk4HAHJJNi5uTkFjiwBjs7RO89x9iMpR0dHOsaOfxJA8EiCOdYQC0llHszM8TsOz5jh2QBa4tS%2bGWPjmqPxzZ%2bRsI0s8o3d1qksnJ15Emk3CX1tfb0GmARq1AzCf3QadRumrf6XqDXsNg5LMVyckZE9mkyettefmsdO/Lpe%2bPcAAAAASUVORK5CYII=' /%3e%3c/svg%3e\" width=\"516\" alt=\"image\" data-srcset=\"/blog/assets/static/loadcss-before-after.a879de3.875bb4ada36869cde6fbd3e2c688de0a.png 516w\" data-sizes=\"(max-width: 516px) 100vw, 516px\" data-src=\"/blog/assets/static/loadcss-before-after.a879de3.875bb4ada36869cde6fbd3e2c688de0a.png\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/blog/assets/static/loadcss-before-after.a879de3.875bb4ada36869cde6fbd3e2c688de0a.png\" width=\"516\" alt=\"image\"></noscript></p>\n<p>이전에는 CSS가 로드되기를 기다리다가 1939번째 줄에서 멈췄지만, 이제는 페이지 끝에서 또 다른 인라인 스크립트가 발생하는 5281번째 줄까지 해석한 후 파서가 다시 블로킹된다.</p>\n<p>이 방법은 빠른 해결책이지만 최종 해결책이 될 수 있는 방법도 아니다. 순서를 바꾸고 preload/polyfill 패턴을 버리는 것은 첫 번째 단계에 불과하다. 여기서 가장 큰 이점은 중요한 CSS를 외부 파일에서 참조하는 대신 인라인화 함으로써 얻을 수 있다(preload/polyfill 패턴은 인라인 CSS와 함께 사용하기 위한 것이다). 이렇게 하면 스크립트 관련 문제를 완전히 무시할 수 있고 브라우저가 첫 번째 네트워크 요청에서 페이지를 렌더링하는 데 필요한 모든 CSS를 확보할 수 있다.</p>\n<p>하지만 당장은 CSS를 로드하는 방식과 DOM 순서를 조금만 변경하면 성능을 크게 향상시킬 수 있다.</p>\n<p>요약하자면</p>\n<ul>\n<li>preload/polyfill 패턴과 함께 loadCSS를 사용하는 경우 대신 print 스타일시트 패턴을 사용하는 것이 좋다.</li>\n<li>정상적으로 로드하는 외부 스타일시트가 있는 경우(즉, 일반적인 스타일시트 링크로 로드하는 경우) 마크업에서 가능한 모든 인라인 스크립트를 그 위로 이동하는 것이 좋다.</li>\n<li>최대한 빠른 렌더링 시작을 위해 중요한 CSS를 인라인화 하는 것이 좋다.</li>\n</ul>\n"}},{"node":{"title":"[번역] Behavior Driven Development(BDD) and Functional Testing","path":"/bdd-and-funtional-testing/","date":"17. September 2020","timeToRead":7,"description":"BDD, Funtional Testing의 개념과 그 필요성에 대해 알아본다.","content":"<blockquote>\n<p>Eric Elliot의 <a href=\"https://medium.com/javascript-scene/behavior-driven-development-bdd-and-functional-testing-62084ad7f1f2/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Behavior Driven Development(BDD) and Functional Testing</a> 번역글입니다. 굳이 이 글이 아니더라도 모든 번역글은 역자의 의도와 상관없이 원문의 내용과 다르게 전달될 수 있으니 원문도 같이 보시는 걸 권해드립니다.</p>\n</blockquote>\n<p>단위 테스트(Unit test)는 코드 단위가 애플리케이션의 나머지 부분과 격리되어 테스트되는 방법이다. 이를 통해 특정 함수, 객체, 클래스, 모듈 등을 테스트할 수 있으며, 애플리케이션의 개별 부분이 잘 작동하는지를 알아보는 데 유용하다.</p>\n<p>하지만 단위 테스트는 이러한 코드 단위가 모여 전체 애플리케이션이 구성되었을 때에도 잘 작동하는지를 테스트하지는 않는다. 이를 위해서는 복수 개의 협동 테스트(Collaboration test)나 E2E 테스트(End-to-end test, aka System test) 등과 같은 통합 테스트(Integration test)가 필요하다.</p>\n<p>시스템 테스트에는 행위 주도 개발(이하 BDD), 기능 테스트(Funtional test)를 포함한 여러 가지 방법론들이 있다.</p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1205 345' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-7a1c7d521cd803a2b5ea88dd9bd73490'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-7a1c7d521cd803a2b5ea88dd9bd73490)' width='1205' height='345' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAASCAIAAABkTU91AAAACXBIWXMAAAsSAAALEgHS3X78AAAFp0lEQVRIx71XiXLbRhLNRyQScWMw9wEMAOIgQIqSLNuKHW2yjqtSlf//kbwhJa3i3UqcXWWruqZ6ehrD7unjNb8hlGvjlLGUCcalsJ1uF%2bVnUQ9Ut5wLxmTb9XXjjXXWNbVvlTJpVlhXG%2bNc3TS%2b2w4jmLr21taQQ4KrOJcVk7pblZ%2bkG0pWmIEFGrloqFuF3XGqq7KkSZbjwq8kKL%2bkbyomjGtATCgulOnX/vphuPkRPlTSKW0gXA9XwziN8w7Wb8ep7beEMls3oGU9zLsVHkC%2bW1YYj9P1cFTagggVql2a3Z2brpM0sxPfvlduEaD%2bTvmjYJIJqZP0f3PANa2tPRyA/VleRFGcxEmSpGma4eokyTebJIrTOM6SJIuTNE4yqMU4zXJscXSmTYTvoJCBx1fh2zSPcVkUY8Vvx3EeR5CEO6NNHkVQKL7e9D9yQNs6RECZklT41SgJtIHFaVGQsqAkzQtQHBewIFh/NmUTVpgCtawos7w8/8YzEwh82J4k%2bRMFnUfmdRwABQekXob2OPdv9sP1rr8/zt7pvCqWn%2bz6yeqBHX5x3a3kNQUz/8OsP7vpI1bb3khY81885%2bs4gOc/RwApxBg3UmgpjJJKcEpZXpWoOdXRoipVz/SWEUn0iUFOy5bWe1EpgpiUlCAOfymhX8cB1F3tO4oWpExekCgpDlP/09v9rw83yzhKL8YPerjXux%2bNnQXsbq6CZPmn3X%2b20w8GAeneqPVn4ybd%2bB7dDCn%2b/46A1PYcgaKs4IOSUkvZOE1IhQzG2%2bPVqakIJ0RUeVkSQSpVUU2orQIvw4rnJxUr8MlTW/xXoj%2bv%2bb/xX1ZC%2bZcdwPPb5rELJVl5uUm%2bu0wuNsnFRbq5yKLHSs0uv82wfZZsLvLL77LNZShiMNGJgRoo1HeUp2lxkqDnFGdJuOe0oloet5vQlIJZ6FdR6FVxlAQ%2bCQ0wirPz0Z860D7iAGCnca0z27YGaOktr1fkDGem4o6ieYcaGLjqGJ4fNe12QtQURygD7iozMtkxnOJIelYyAgXAFhjZAg6Z8BQ3qG04kmDCbUGIQBUEVw1MewHIoxLgQCnVRiAjvgCK/%2bCA73p3igCyad62b9btfls7YyqdDfdq/WzkloiO%2bBuGbXPkduEZLfytGB4Uays50fEHJTt4yJuDGD7o5ooPH0UhMj2R7i0nMnf7Sk/wmffvAGQc5Y6ngXsoHvhQwQjb%2bv19u7%2bv51sqnFSGctZ1aCpCmxoB%2bWMkrs8RQAoFBMiIaPeq29fjXZoKZ733cKgbhrUiilZac/12P051A2SefLMgatzYzsIy9CupTZ4y31yN0y3WtjmOw5varbUbo016TrnkKbuwPQFLCYiMNlGAxSgC5p1TKADR16QQihiz0FMRk4Iw1c6yHnW3FJTX3mMoQIjGeQ5FKiTjfN36oXfHteu9XQZvlKIizDbIB0xB8MF3S9sd2n7Vpm27pfZz4wfUa/b7IsY2ewl5z%2btzD/jTIsYw1/bDizZaFoS78cYNR7%2b8C750/bLud%2bseQw7GnmkHm5D4OqVZ/0HNnzRx5fLJzA86K4rlkwXADd9LrpDZ%2beUmzCUYMVCf0Wma%2bFvaKGD4OYUQAQCScFtmWtlMKCGtrW976zzyEt0WI2cYMylH3IFfdgoDmUIeo5/SygwIQkV0CQVQnOQloX8vDiACL4EMGiVV491nv75HSVFhkD5I8o/X08Pt7t3VuPQ1hufD1fUwzct6tdsdbN1uG//han5/XIZhmXeH29t3iNgwzrd3b6%2bON7gB2PJaCP2lA7C76XrtnkYJLkM/1b4SrhImCxiGtA7DRa2VFIJRVgWBCuUQegWHAgQW4Cf4SVeFijpFCfw5FL8b717XAdTw4fqmaR8jgD8n4zTDxJCy6WPzOiFLmE%2bfh%2bTHUfk8b5/5BNtnPnup9rrT0RcO/AYMs%2bJdWTHwHwAAAABJRU5ErkJggg==' /%3e%3c/svg%3e\" width=\"1205\" alt=\"image\" data-srcset=\"/blog/assets/static/bdd-and-funtional-testing.82a2fbd.5fae081731a71128ab579a2f53e4d3ac.png 480w, /blog/assets/static/bdd-and-funtional-testing.49ad50f.5fae081731a71128ab579a2f53e4d3ac.png 1205w\" data-sizes=\"(max-width: 1205px) 100vw, 1205px\" data-src=\"/blog/assets/static/bdd-and-funtional-testing.49ad50f.5fae081731a71128ab579a2f53e4d3ac.png\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/blog/assets/static/bdd-and-funtional-testing.49ad50f.5fae081731a71128ab579a2f53e4d3ac.png\" width=\"1205\" alt=\"image\"></noscript></p>\n<hr>\n<h1 id=\"행위-주도-개발이란-무엇인가\"><a href=\"#%ED%96%89%EC%9C%84-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>행위 주도 개발이란 무엇인가?</h1>\n<p>BDD는 테스트 주도 개발(Test Driven Development)의 한 분야이다. BDD는 사람이 읽을 수 있는 사용자 요구사항 명세를 소프트웨어 테스트의 기반으로 사용한다. 도메인 주도 설계(Domain Driven Design)와 마찬가지로, BDD의 초기 단계는 이해관계자, 도메인 전문가, 엔지니어 간의 공유된 어휘를 정의하는 것이다. 이 단계에서는 엔티티, 이벤트, 출력 등을 정의하고, 정의한 요소들에 모두가 동의할 수 있는 이름을 지정하는 작업들이 포함된다.</p>\n<p>그 후 실무자들은 사용자 인수 테스트(User Acceptance Test)와 같은 시스템 테스트를 작성하는데 사용할 수 있는 도메인 별 언어(Domain Specific Language)를 만들기 위해 이 어휘들을 사용한다.</p>\n<p>각 테스트는 영어와 공식적으로 지정된 유비쿼터스 언어(모든 이해관계자가 공유하는 어휘)로 작성된 사용자 스토리를 기반으로 한다.</p>\n<p>예를 들어 암호화폐 지갑의 이체 테스트는 아래와 같다.</p>\n<pre><code>스토리: 이체 후 잔액 변경\n\n지갑 사용자로서\n돈을 보내기 위해\n지갑 잔액을 업데이트 해야한다.\n\n내 잔액이 $40 이고,\n친구 잔액이 $10 임을 감안할 때,\n친구에게 $20을 송금하면\n내 잔고는 $20이 되어야 한다.\n그리고 친구는 $30이 되어야 한다.\n</code></pre>\n<p>이 언어는 소프트웨어의 UI나 목표를 달성하는 방법 보다는 고객이 소프트웨어로부터 얻어야 하는 비즈니스 가치에만 초점을 맞춘다는 것에 유의해야 한다. 대신 UX 디자인 프로세스의 시작점으로 사용할 수 있고, 이러한 종류의 사용자 요구사항을 미리 설계하면 실무자들과 고객이 어떤 제품을 만들고 있는지에 대해 동일한 입장을 취할 수 있도록 도울 수 있어 프로세스 후반에 생길 수 있는 많은 재작업들을 줄일 수 있다.</p>\n<p>이 단계에서 아래 두 단계로 진행할 수 있다.</p>\n<ol>\n<li>설명을 도메인 별 언어로 변환하여 human-readable한 설명에 machine-readable한 코드가 추가되도록 테스트에 구체적인 기술적 의미를 부여한다. (즉 BDD를 계속 진행)</li>\n<li>사용자 스토리를 JavaScript, Rust 등과 같은 범용 언어를 활용하여 자동화된 테스트로 변환한다. (기능 테스트로 전환)</li>\n</ol>\n<p>보통 어느 쪽이든 블랙박스 테스트로 처리하여 테스트 코드가 테스트 중인 기능의 구현 세부사항에 신경을 안 쓰게끔 하는 것이 좋다. 블랙박스 테스트는 화이트박스 테스트와 달리 구현 세부사항과 결합되지 않으므로 요구사항이 추가/변경되거나 코드가 리팩토링될 때 상대적으로 덜 취약하다.</p>\n<p>BDD 지지자들은 <a href=\"https://github.com/cucumber/cucumber-js/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Cucumber</a>와 같은 도구를 사용하여 맞춤형 DSL을 만들고 관리한다.</p>\n<p>이와 반대로, 기능 테스트 지지자들은 일반적으로 사용자 인터랙션을 시뮬레이션하고 실제 출력과 예상 출력을 비교하여 기능을 테스트한다. 웹 애플리케이션의 경우, 이는 보통 타이핑, 버튼 클릭, 스크롤, 확대/축소, 드래그 등을 시뮬레이션하기 위해 웹 브라우저와 상호작용하는 테스트 프레임워크를 사용하는 것을 의미한다.</p>\n<p>필자(<em>역주: Eric Elliot</em>)는 일반적으로 BDD를 유지하기보단 사용자 요구사항을 기능 테스트로 변환하는 것을 선호한다. 애플리케이션과 BDD 프레임워크를 통합하는데 요구되는 복잡성과 여러 시스템 및 구현 언어들에 걸쳐있는 DSL 유지보수 비용이 높기 때문이다.</p>\n<p>또한 human-readable한 DSL은 이해관계자들과의 커뮤니케이션 용도로써 고수준의 명세서에는 적합하지만, 일반적인 소프트웨어 시스템은 제품 장애를 일으키는 버그를 방지하기 위한 적절한 코드와 테스트 커버리지 생성을 위해 더 낮은 수준에서의 테스트가 필요할 것이다.</p>\n<p>예를 들어 \"친구에게 $20을 송금한다.\" 요구사항은 다음과 같이 변환되어야 한다.</p>\n<ol>\n<li>지갑 오픈</li>\n<li>송금 클릭</li>\n<li>금액 입력</li>\n<li>송금 지갑 주소 입력</li>\n<li>송금하기 클릭</li>\n<li>확인 모달 대기</li>\n<li>거래확인 클릭</li>\n</ol>\n<p>화면 아래의 계층에서는 송금 관련 워크플로우의 상태를 관리하며 정확한 금액이 지갑 주소로 전송되는지 단위 테스트를 필요로 할 것이다. 이보다 더 아래의 계층에서는 실제로 지갑 잔액이 적절하게 변경되었는지 확인하기 위해 블록체인 API를 활용할 것이고, 이러한 과정들은 클라이언트가 확인하기 힘들다.</p>\n<p>이러한 서로 다른 테스트 요구사항은 각기 다른 테스트 단계에서 가장 잘 처리할 수 있다.</p>\n<ol>\n<li>단위 테스트는 로컬 클라이언트 상태가 올바르게 업데이트 되고, 이에 따라 화면에 올바르게 표시되는지 테스트할 수 있다.</li>\n<li>기능 테스트는 UI 인터랙션과 UI 상에서 사용자 요구사항이 충족되었는지 테스트할 수 있다. 이를 통해 UI 요소들이 적절히 연결되었는지도 확인할 수 있다.</li>\n<li>통합 테스트는 API 통신이 제대로 이루어지고 있는지, 사용자 지갑 금액이 실제로 블록체인 상에 올바르게 반영되었는지 테스트할 수 있다.</li>\n</ol>\n<p>필자는 하위 계층 동작은 말할 것도 없고, 최상위 계층인 UI 동작을 검증하는 모든 기능 테스트를 조금이라도 이해하고 있는 이해관계자들을 본 적이 없다. 정작 이들은 관심이 없는데 DSL을 만들고 유지보수하는데 비용을 들일 필요가 있을까? 전체 BDD 프로세스를 수행하든 안 하든, 우리가 놓치지 말아야 할 훌륭한 아이디어와 관행들이 많다.</p>\n<ul>\n<li>엔지니어와 이해관계자들이 사용자 요구사항과 소프트웨어 솔루션에 대해 효과적으로 의사소통을 하기 위한 공유 어휘를 정의해야 한다.</li>\n<li>소프트웨어의 특정 기능에 대한 허용 기준 및 수행 완료의 정의를 위한 사용자 스토리 및 시나리오를 작성해야 한다.</li>\n<li>사용자, 제품팀, 품질팀, 엔지니어 간의 협업을 통해 팀이 구축하고 있는 내용에 대한 합의를 도출해야 한다.</li>\n</ul>\n<p>그렇다면 또 다른 시스템 테스트 중 하나인 기능 테스트는 무엇일까?</p>\n<hr>\n<h1 id=\"기능-테스트란-무엇인가\"><a href=\"#%EA%B8%B0%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기능 테스트란 무엇인가?</h1>\n<p>기능 테스트란 용어 자체는 여러 의미를 갖고 있기 때문에 혼란스러울 수 있다. <a href=\"https://www.iso.org/standard/71952.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IEEE 24765</a>는 아래 두 의미로 정의하고 있다.</p>\n<ol>\n<li>시스템 또는 구성 요소의 내부 메커니즘을 무시하고 선택한 입력 및 실행 조건에 대한 응답으로 생성된 출력에만 초점을 맞춘 테스트 (예: 블랙박스 테스트)</li>\n<li>특정 기능 요구사항을 가진 시스템 또는 구성 요소의 적합성을 평가하기 위해 수행되는 테스트</li>\n</ol>\n<p>첫 번째 정의는 거의 모든 테스트 방식에 적용될 만큼 일반적이며, 이미 소프트웨어 테스터들이 완벽하게 이해하고 있는 블랙박스 테스트가 있다. 두 번째 정의는 일반적으로 앱의 기능과는 직접적인 관련이 없는 로딩 시간, UI 응답 시간, 서버 로드 테스트, 보안 침투 테스트 등 앱의 다른 특성에 중점을 둔다. 이 정의는 꽤나 모호해서 그 자체만으로는 유용하지 않다. 때문에 우리는 보통 단위 테스트, 스모크 테스트, 사용자 인수 테스트 등 어떤 종류의 테스트를 우리가 수행해야 하는지 더 구체적으로 알고 싶어한다.</p>\n<p>이러한 이유로 필자는 IBM의 Developer Works에서 정의한 다음을 선호한다.</p>\n<p><strong><em>기능 테스트는 사용자 관점에서 작성되며, 사용자가 관심을 갖는 시스템 동작에 초점을 맞춘다.</em></strong></p>\n<p>이는 훨씬 더 명확하지만 우리가 테스트를 자동화하고 해당 테스트를 사용자 관점에서 수행할 거라면, 그것은 UI와 상호작용하는 테스트를 작성해야 함을 의미한다. 이러한 테스트는 \"UI 테스트\" 또는 \"E2E 테스트\"라는 이름으로도 불릴 수 있지만, \"친구에게 돈을 송금할 수 있어야 한다.\"와 같은 사용자 요구사항과 직접적인 관련이 없는 스타일이나 색상 등을 테스트하는 UI 테스트 클래스가 있기 때문에 기능 테스트라는 용어의 필요성을 대체하지는 않는다.</p>\n<p>단위 테스트(애플리케이션의 나머지 부분으로부터 독립된 함수, 객체, 클래스, 모듈 등 개별 코드 단위의 테스트)와는 대조적으로 기능 테스트는 사용자 요구사항을 충족하는지 확인하기 위한 사용자 인터페이스 테스트에 적용된다. 즉, UI와 상호작용하는 사용자의 관점에서 애플리케이션의 나머지 부분들과 통합하여 테스트하는 것이다.</p>\n<p>필자는 개발자 관점에서의 코드 단위에 대한 단위 테스트와 사용자 관점에서의 UI 테스트에 대한 기능 테스트로 분류하고자 한다.</p>\n<hr>\n<h1 id=\"단위-테스트-vs-기능-테스트\"><a href=\"#%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-vs-%EA%B8%B0%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단위 테스트 vs 기능 테스트</h1>\n<p>단위 테스트는 보통 소프트웨어를 구현하는 개발자가 작성하고, 개발자의 관점에서 테스트한다. 기능 테스트는 사용자 인수 기준에 의해 진행되며 사용자 요구사항이 충족되는지 사용자의 관점에서 애플리케이션을 테스트해야 한다.</p>\n<p>단위 테스트는 독립된 개별 단위의 코드를 테스트하기 위해 작성되며, 아래와 같은 이점이 있다.</p>\n<ol>\n<li>단위 테스트는 시스템의 다른 부분에 종속되지 않기 때문에 매우 빠르게 실행되며, 일반적으로 대기할 비동기 I/O가 없다. 또한 보통 밀리 초 단위로 완료되기 때문에 전체 시스템이 실행될 때까지 기다리는 것보다 단위 테스트에서 결함을 찾아 수정하는 것이 훨씬 빠르고 비용이 적게 든다.</li>\n<li>시스템의 다른 부분과 쉽게 분리하여 테스트할 수 있도록 모듈화를 하는 것이 중요한데, 이는 시스템 아키텍처에 큰 이점이 된다. 모듈화된 코드는 변경되더라도 그 영향이 특정 모듈로 국한되기 때문에 확장, 유지보수, 교체 등이 수월하다. 이러한 모듈화가 전체 애플리케이션에 적용되면 개발자가 더 쉽고 유연하게 작업이 가능하다.</li>\n</ol>\n<p>반면에 기능 테스트는 아래와 같은 특징이 있다.</p>\n<ol>\n<li>사용자 관점에서 동작을 테스트하기 위해 애플리케이션 내 관련된 모든 의존성을 통합하여 테스트해야 하므로 실행시간이 더 오래 걸린다. 규모에 따라 몇 시간 이상이 걸리기도 하며, 10분 이내에 완료될 수 있도록 병렬로 실행되게끔 최적화를 하는 것이 좋지만 그래도 여전히 오래 걸린다.</li>\n<li>모듈들이 전체 시스템으로 통합되어서도 잘 동작하는지 테스트를 해야 한다. 기능 테스트는 모듈들이 모여 시스템이 완전히 통합되었을 때, 시스템 전체가 예상대로 잘 동작하는지 확인하는 시스템 테스트의 한 형태이다.</li>\n</ol>\n<p>단위 테스트가 없는 기능 테스트는 지속적인 서비스 제공(<em>Continuous Delivery</em>)을 위한 안전성을 확신할 만큼의 코드 커버리지를 제공할 수 없다. 단위 테스트는 코드 커버리지의 깊이를 제공하며, 기능 테스트는 사용자 요구사항 테스트 케이스의 범위를 제공한다. 즉, 둘 다 필요하다.</p>\n<p><strong><em>기능 테스트는 올바른 제품을 구축하는데 도움이 된다.(Validation)</em></strong>\n<strong><em>단위 테스트는 제품을 올바르게 구축하는데 도움이 된다.(Verification)</em></strong></p>\n<p>(참고 1) <a href=\"https://en.wikipedia.org/wiki/Software_verification_and_validation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Validation &#x26; Verification</a></p>\n<p>(참고 2) <a href=\"https://en.wikipedia.org/wiki/Barry_Boehm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Barry Boehm</a>은 올바른 제품을 구축하는 것과 제품을 올바르게 구축하는 것에 대한 차이를 간결하게 설명했다.</p>\n<hr>\n<h1 id=\"기능-테스트에서-해야할-일과-하지-말아야할-일\"><a href=\"#%EA%B8%B0%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%ED%95%B4%EC%95%BC%ED%95%A0-%EC%9D%BC%EA%B3%BC-%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC%ED%95%A0-%EC%9D%BC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기능 테스트에서 해야할 일과 하지 말아야할 일</h1>\n<ul>\n<li>DOM을 변경하면 안된다. DOM을 변경하면 테스트 러너가 DOM이 어떻게 변경되었는지 이해하지 못할 수 있고, DOM 출력에 의존하는 다른 테스트에 영향을 끼칠 수 있다.</li>\n<li>테스트 간에 변경 가능한 상태(mutable state)를 공유하면 안된다. 기능 테스트는 너무 느리기 때문에 병렬로 실행하는 것이 매우 중요한데, 공유되어 있는 동일한 변경 가능한 상태에 대해 경쟁하는 경우, 경쟁 조건(race condition)으로 인해 상태가 결정되지 않아 테스트가 실패할 수 있다. 시스템 테스트를 실행 중이므로, 사용자 데이터를 수정하는 경우 서로 다른 테스트에 대해 서로 다른 테스트 데이터가 있어야 한다.</li>\n<li>기능 테스트를 단위 테스트와 혼합하면 안된다. 단위 테스트와 기능 테스트는 다른 관점에서 다른 시간에 실행되어야 한다. 단위 테스트는 개발자의 관점에서 작성되어야 하고, 개발자가 코드를 수정할 때마다 실행되어야 하며 3초 이내에 완료되어야 한다. 기능 테스트는 사용자의 관점에서 작성되어야 하고, 개발자의 즉각적인 피드백을 위한 비동기 I/O를 포함해야 한다. 기능 테스트 실행을 트리거하지 않고도 단위 테스트를 쉽게 실행할 수 있어야 한다.</li>\n<li>가능한 경우 헤드리스 모드를 통해 테스트를 실행하면 좋다. 브라우저를 실제로 실행할 필요가 없어 더 빠른 테스트가 가능하다. 헤드리스 모드는 대부분의 기능 테스트 속도를 높일 수 있는 좋은 방법이지만, 헤드리스 모드에서 동작하지 않는 기능들이 있어 일부 테스트는 실행할 수 없다. 일부 CI/CD 파이프라인은 헤드리스 모드에서 기능 테스트를 실행해야 하므로, 헤드리스 모드에서 실행할 수 없는 테스트가 있을 경우 QA 팀이 해당 테스트 케이스를 관리해야 한다.</li>\n<li>모바일을 포함한 여러 디바이스에서 테스트를 실행해야 한다.</li>\n<li>테스트 실패에 대한 스냅샷을 찍으면 좋다. 테스트가 잘못된 부분을 제대로 잡아내지 못할 경우 스냅샷이 유용할 수 있다.</li>\n<li>기능 테스트 실행을 10분 미만으로 유지해야 한다. 안 그러면 각 기능 테스트에 대한 작업과 잘못된 부분을 수정하는 사이에 너무 많은 지연이 발생한다. 10분이면 다음 테스트를 실행하는데 충분하며, 10분 이상 지난 후 테스트가 실패하면 다음 테스트로 넘어간 개발자가 하던 작업을 중단하고 다시 돌아와서 작업해야 하므로 비효율적이다. 이렇게 중단된 작업은 완료하는데 평균 두 배의 시간이 걸리고 에러도 대략 두 배 정도 포함된다.</li>\n<li>테스트에 실패하면 CI/CD 파이프라이닝을 멈추도록 설정하는게 좋다. 자동화된 테스트의 큰 장점 중 하나는 작동하던 기능의 버그로부터 고객들을 보호할 수 있다는 것이다. 이러한 테스트 성공여부에 따른 CI/CD 프로세스를 자동화할 수 있으므로 배포 시 버그가 없다는 확신을 가질 수 있다. CI/CD 파이프라인에서 테스트를 수행하면 개발팀의 생산성을 크게 떨어뜨리는 변화에 대한 두려움도 효과적으로 제거할 수 있다.</li>\n</ul>\n<hr>\n<p><em>역주: 원문의 내용 중 TestCafe 등 특정 테스트 도구에 관한 내용은 제외하였습니다.</em></p>\n"}},{"node":{"title":"[번역] The process: Making Vue 3","path":"/the-process-making-vue3/","date":"20. July 2020","timeToRead":8,"description":"Vue.js의 메이저 버전을 준비하며 얻은 교훈들","content":"<blockquote>\n<p>Evan You의 <a href=\"https://increment.com/frontend/making-vue-3/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The process: Making Vue 3</a> 번역글입니다. 굳이 이 글이 아니더라도 모든 번역글은 역자의 의도와 상관없이 원문의 내용과 다르게 전달될 수 있으니 원문도 같이 보시는 걸 권해드립니다.</p>\n</blockquote>\n<p>지난 1년동안 Vue 개발팀은 Vue.js의 다음 메이저 버전을 준비해왔으며, 2020년 상반기 release를 목표로 하고 있다. <em>(역주: 참고로 원문은 2020년 5월 3일에 포스팅되었다.)</em> 새로운 메이저 버전은 2018년 말, Vue 2의 코드베이스가 약 2년 반정도 되었을 때 구체화되었다. 소프트웨어 수명치고 그리 오래되지 않았을 수 있지만 해당 기간동안 프론트엔드 환경은 크게 바뀌었고, 다음 두 요소로 인해 Vue의 새로운 메이저 버전을 만들게 되었다.</p>\n<ul>\n<li>주요 브라우저에서 JavaScript 신규 기능들의 가용성을 어느정도 보장함</li>\n<li>시간이 흐르면서 현재 코드베이스의 설계 및 구조에서 오는 문제점들이 드러남</li>\n</ul>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1000 563' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6d540a3f6519b716b96d1304b5605b26'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6d540a3f6519b716b96d1304b5605b26)' width='1000' height='563' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAkAEADASIAAhEBAxEB/8QAHAAAAQUBAQEAAAAAAAAAAAAAAAEDBAYHCAIF/8QALxAAAgECBQMCBAYDAAAAAAAAAQIDBBEABRIhMQYTQQdxFCIyYRUjNVGBkaHB4f/EABkBAAIDAQAAAAAAAAAAAAAAAAAEAQIFA//EACcRAAIBAwMDAwUAAAAAAAAAAAECAAMRIQQSMUFhoRNR8BRCgbLh/9oADAMBAAIRAxEAPwDpxmClQTYsbDA2rbTbne/7YXFZ6ozHNqJ/hqDJ6ivppoyrTRzaWUtcEcXFhwcZc6s20X/s%2bd1X1nSZXSVk1FDI2Yxjto0sLmJirDUpZb24I98VCf1hkiamq5qempqBVAqC4ckEm23nyNrXO%2bKAlbLDn/UOTVucfA5Y1Q5ip62yRS6SFkjaQC6EgBrAWPzXFr4lM1FmPS9THVUiJWUeuJa2FrxyGK8mhZVO/wCWCLkeOcJ/VlCQ63sclb4U8MQQMDhrE28S9fQVnI2Pt4NrfnzLZSeq%2bcNBVU5jy%2bSpia8c5LAMCotqjG4sb8HcAcb4u3T3V%2bTdTNIKLM5qeraUwxo8mxP2A487XuCLYw%2brhy6l6M/FKRojndYvxMInmdgsR1WVz9IAAO5%2b%2b%2bLZ6SOo6lh7OUwzVB0PUVbISsEVm%2blrAatZFid7XsN8OUaiVkZ6YOCRnt1HuDnMzH9fTVlpO24G3z3%2bZm%2bKwZQwvYi/FsCnUoNitxweRhIlZYwJH1t5bTa/8Y9YJpSHOcw/EoRAtL8AVPcZy3cDb8AbW4/zgrGkWFpaZEmnAsqtJpGobWB3sTuL298TPHGGLO0EehFjIIJWQarAex5xEJxV6h1M6Q1dTM0kdWucM8rOlmSTW2okW8G/jfEqHqui6p/VKiiyyvpo1DIsHZNVa4co/wBIcrcaWFj4PjE71Jy3NM060z7LckQ1NY2byvHCjhZDdiTz4sf6xnM/S9dEjPGsDuHbURURFUPAAOrfck7bYsunVrEmzLweve/Y9Y9qXbepUfav6ibplHT%2bXN0jPUyVNXIs0TTxU8koKiJB%2bWjLbc6RxxxfjFr9F8wo/gszr44a6WQSR0q9iIsyqy6gSOLXHJxzn09mHUeUstNBKtXRqLdqomRdI/ZXJ/5jpL0Fra%2bupsxcSB6aKdO8GszglLgLp2P88c3PGFqS6mm9RarBlY3B6r2HicdRSoVVWttO5cZmxre7E6t/B8e2Fv8AMFseL38YRfkCJ87eNR3/ALOEMqidYTfWylx7Agf7wxF43LSQyzdx1YvtuHYccbA2w/gwYISNVBaenqJokRZAhOrSN/fERMqozU98wR91nExbQL6tjzb7DBgxBUNyJHEkrl9IBMBTxWkN3soGr3th6GMC5O5DkjYC39YMGJkWzHceDEpmWU31qpUb7WJBO38DBgwS0//Z' /%3e%3c/svg%3e\" width=\"1000\" alt=\"image\" data-srcset=\"/blog/assets/static/the-process-making-vue3.82a2fbd.c83568af679d5521d280e854c15cdcb5.jpg 480w, /blog/assets/static/the-process-making-vue3.97c148e.c83568af679d5521d280e854c15cdcb5.jpg 1000w\" data-sizes=\"(max-width: 1000px) 100vw, 1000px\" data-src=\"/blog/assets/static/the-process-making-vue3.97c148e.c83568af679d5521d280e854c15cdcb5.jpg\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/blog/assets/static/the-process-making-vue3.97c148e.c83568af679d5521d280e854c15cdcb5.jpg\" width=\"1000\" alt=\"image\"></noscript></p>\n<hr>\n<h1 id=\"왜-재구현을-하게-되었나\"><a href=\"#%EC%99%9C-%EC%9E%AC%EA%B5%AC%ED%98%84%EC%9D%84-%ED%95%98%EA%B2%8C-%EB%90%98%EC%97%88%EB%82%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>왜 재구현을 하게 되었나</h1>\n<h3 id=\"javascript의-신규-기능-활용\"><a href=\"#javascript%EC%9D%98-%EC%8B%A0%EA%B7%9C-%EA%B8%B0%EB%8A%A5-%ED%99%9C%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JavaScript의 신규 기능 활용</h3>\n<p>ES2015가 표준화되면서 JavaScript가 크게 개선되었고, 주요 브라우저들은 이러한 신규 기능을 지원하기 시작했다. 그 중 일부는 Vue가 가진 기능을 크게 향상시킬 수 있는 기회를 제공했다.</p>\n<p>특히 주목할만한 것은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Proxy</a>인데, 이는 Vue가 object에서 이루어지는 작업들을 intercept 할 수 있게 해준다. Vue의 핵심 기능은 사용자가 정의한 state의 변경을 감지하고 이에 반응하여 DOM을 수정하는 것이다. Vue 2는 state 객체의 속성을 getter와 setter로 대체하여 이러한 반응성을 구현한다. 이를 Proxy로 전환하면 새로운 속성 추가를 감지하지 못하는 등의 제약사항을 제거할 수 있고, 성능 향상을 꾀할 수 있다.</p>\n<p>하지만 Proxy는 오래된 브라우저에서는 완전하게 pollyfill 될 수 없는 기능이며, 이를 활용하기 위해서는 새로운 메이저 버전의 브라우저 지원 범위를 조정해야만 한다는 것을 인지하고 있다.</p>\n<h3 id=\"구조적-문제-해결\"><a href=\"#%EA%B5%AC%EC%A1%B0%EC%A0%81-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>구조적 문제 해결</h3>\n<p>Vue 2를 유지보수하는 과정에서 기존 구조의 한계로 인해 해결하기 어려운 문제들이 쌓여왔다. 예를 들어 템플릿 컴파일러는 적절한 source-map을 지원하기가 매우 어렵게 구현되어 있다. 또한, Vue 2는 기술적으로 DOM 이외의 플랫폼을 대상으로 고수준의 렌더러 역할을 할 수 있지만, 이를 가능하게 하기 위해 수많은 fork와 중복된 코드를 만들어 냈다. 현재 코드베이스에서 이러한 문제들을 해결하려면 거의 재구현 수준의 매우 위험한 리팩토링이 필요하다.</p>\n<p>이와 동시에, 우리는 다양한 모듈들의 내부와 어디에도 속하지 않는 코드들을 암묵적 결합의 형태로 구현하여 기술 부채를 쌓아왔다. 이로 인해 코드의 일부를 독립적으로 이해하기가 어려워졌으며, contributor들이 사소한 변경을 하는 것에도 확신이 없다는 것을 알게 되었다. 재구현을 하게 되면 이러한 점들을 염두에 두고 코드 구성을 다시 생각할 수 있다.</p>\n<hr>\n<h1 id=\"초기-프로토타이핑-단계\"><a href=\"#%EC%B4%88%EA%B8%B0-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9D%B4%ED%95%91-%EB%8B%A8%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>초기 프로토타이핑 단계</h1>\n<p>우리는 상기 문제들에 대한 솔루션을 검증하는 예비 목표를 세우고 2018년 말에 Vue 3의 프로토타이핑을 시작했다. 이 단계에서 우리는 추가 개발을 위한 견고한 기반을 닦는 것에 중점을 두었다.</p>\n<h3 id=\"typescript로의-전환\"><a href=\"#typescript%EB%A1%9C%EC%9D%98-%EC%A0%84%ED%99%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>TypeScript로의 전환</h3>\n<p>Vue 2는 일반 ES로 구현되었다. 프로토타이핑 단계 직후, 우리는 타입 시스템이 이 정도 규모의 프로젝트에 큰 도움이 될 것임을 깨달았다. 타입 체크는 리팩토링 중에 예기치 않은 버그가 발생할 가능성을 크게 줄여주고, contributor들이 확신을 갖고 코드에 기여할 수 있게 해준다. 우리는 ES에 추가될 가능성을 보고 Facebook의 <a href=\"https://flow.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Flow</a>를 채택했었다. Flow는 어느 정도 도움이 되었지만 우리가 원하는 수준만큼은 아니었는데, 특히 잦은 변화로 인해 계속 대응하며 업그레이드하는 것이 어려웠다. IDE에 대한 지원도 TypeScript와 비교하면 만족스럽지 않았다.</p>\n<p>또한 Vue와 TypeScript를 함께 사용하는 사용자가 점점 증가하는 것을 알게 되었다. 이러한 케이스를 지원하기 위해서는 Flow로 구현된 코드와 별도로 TypeScript 선언을 작성하고 유지해야만 했다. TypeScript로 전환하면 이러한 고민이 필요없으므로 유지관리 부담을 줄일 수 있다.</p>\n<h3 id=\"내부-모듈들의-decoupling\"><a href=\"#%EB%82%B4%EB%B6%80-%EB%AA%A8%EB%93%88%EB%93%A4%EC%9D%98-decoupling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>내부 모듈들의 Decoupling</h3>\n<p>우리는 프레임워크가 각각의 개별 API, 타입 정의, 테스트 등이 내부 패키지로 구성되는 monorepo 설정을 채택했다. 각 모듈들 간의 의존성이 명확해져 개발자들이 더 이해하기 쉽게 만들고자 했다. 이러한 구성의 핵심은 프로젝트의 contribution 장벽을 낮춰 장기적인 유지보수성을 향상시키고자 함이다.</p>\n<h3 id=\"rfc-프로세스-설정\"><a href=\"#rfc-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RFC 프로세스 설정</h3>\n<p>2018년 말에 새로운 반응형 시스템과 가상 DOM 렌더러로 작동하는 프로토타입을 가지게 되었다. 우리는 우리가 원했던 내부 아키텍처 개선을 검증했지만 사용자 API 변경에 대한 대략적인 초안만 작성되어 있었고, 이를 구체적인 설계로 바꿀 때였다.</p>\n<p>우리는 이것을 일찍, 신중하게 해야 한다는 것을 알고 있었다. Vue가 널리 사용되고 있다는 것은 곧 이러한 큰 변화가 사용자의 막대한 마이그레이션 비용을 유발하고 잠재적인 생태계 파편화로 이어질 수 있음을 의미하기 때문이다. 하여 변경사항에 대한 피드백을 사용자로부터 받을 수 있도록 2019년 초에 <a href=\"https://github.com/vuejs/rfcs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RFC</a> 프로세스를 적용했다. 각 RFC는 템플릿을 따르며 이는 동기, 설계 세부사항, 장단점, 채택 전략에 중점을 둔 섹션으로 구성되어 있다. GitHub 레포에서 PR을 통해 프로세스가 진행되기 때문에 유기적으로 논의가 진행된다.</p>\n<p>우리가 잠재적 변화의 모든 측면을 충분히 고려할 수 있게끔 하고, 커뮤니티가 설계 프로세스에 참여하도록 하여 충분히 검토된 기능을 요청하게 한다는 점에서 RFC 프로세스는 사고방식의 도구로써 매우 유용하다는 것이 입증되었다.</p>\n<hr>\n<h1 id=\"더-빠르게-더-작게\"><a href=\"#%EB%8D%94-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%8D%94-%EC%9E%91%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>더 빠르게, 더 작게</h1>\n<p>성능은 프론트엔드 프레임워크에 필수적이다. Vue 2는 경쟁력있는 성능을 자랑하지만, 재구현을 통해 새로운 렌더링 전략을 실험함으로써 훨씬 더 발전할 수 있는 여지를 갖게 되었다.</p>\n<h3 id=\"가상-dom의-병목-현상-극복\"><a href=\"#%EA%B0%80%EC%83%81-dom%EC%9D%98-%EB%B3%91%EB%AA%A9-%ED%98%84%EC%83%81-%EA%B7%B9%EB%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>가상 DOM의 병목 현상 극복</h3>\n<p>Vue는 매우 독특한 렌더링 전략을 갖고 있다. HTML과 비슷한 템플릿을 제공하고, 이는 가상 DOM 트리를 반환하는 렌더 함수를 통해 컴파일된다. Vue는 두 개의 가상 DOM 트리를 재귀적으로 탐색하여 모든 노드의 모든 속성을 비교 후 실제 DOM의 어느 부분을 업데이트할 지 파악한다. 이러한 brute-force 식 알고리즘은 최신 JavaScript 엔진에서 수행하는 최적화 덕분에 대체로 매우 빠르지만, 여전히 불필요한 CPU 작업을 많이 필요로 한다. 특히 거대한 정적 컨텐츠 내부에 약간의 동적 바인딩이 포함되어 있는 템플릿의 경우 위와 같이 가상 DOM 트리 전체를 훑는 것은 매우 비효율적이다.</p>\n<p>다행스럽게도 템플릿 컴파일 단계에서 템플릿에 대한 정적 분석을 수행하여 동적인 부분에 대한 정보를 추출할 수 있다. Vue 2에서는 정적 서브트리를 건너 뛰는 방식으로 어느 정도까지는 이를 수행했지만 컴파일러 아키텍처가 지나치게 단순한 관계로 이 이상의 최적화를 구현하기 어려웠다. Vue 3에서는 적절한 <a href=\"%5Bhttps://en.wikipedia.org/wiki/Abstract_syntax_tree%5D(https://en.wikipedia.org/wiki/Abstract_syntax_tree)\">AST</a> 변환을 사용해 컴파일러를 재구현했고, 이를 통해 플러그인 형식으로 컴파일 타임 최적화를 구현할 수 있다.</p>\n<p>또한 새로운 아키텍처로 구성하게 된김에 우리는 가능한 많은 오버헤드를 제거하는 렌더링 전략을 찾고 싶었다. 한 가지 옵션은 가상 DOM을 버리고 명령형 DOM 작업을 직접 생성하는 것이었는데, 이렇게 하면 가상 DOM 렌더링 기능을 직접 작성할 수 있는 기능이 제거될 것이고, 이는 고급 사용자 및 라이브러리 제작자에게 매우 유용한 기능을 없애버리는 꼴이었다. Vue와 그 생태계의 거대한 변화까지 불러오는 것은 덤이다.</p>\n<p>다음으로 생각한 것은 DOM 업데이트 시 가장 많은 오버헤드를 유발하는 불필요한 가상 DOM 트리 탐색과 속성 비교를 제거하는 것이었다. 이를 위해서는 컴파일러와 런타임이 유기적으로 동작해야 하는데, 컴파일러가 템플릿을 분석하고 최적화 힌트와 함께 코드를 생성하면 런타임은 힌트를 보고 가능한 빠른 경로를 택해야 한다. 이 과정은 다음 세 가지의 주요 최적화 과정을 통해 이루어진다.</p>\n<ul>\n<li>첫째로, 우리는 트리 레벨에서 노드 구조를 동적으로 변경하는 directive(v-if, v-for 등)가 없는 경우, 노드 구조가 완전히 정적으로 유지된다는 것을 알게되었다. 템플릿을 이러한 directive로 구분하여 중첩된 블록으로 나누면 각 블록 내의 노드 구조는 완전히 정적으로 된다. 때문에 블록 내의 노드를 업데이트할 때 더이상 트리를 재귀적으로 탐색할 필요가 없으며, 블록 내의 동적 바인딩은 flat array로 추적할 수 있게 되었다. 이러한 최적화는 트리 탐색의 양을 크게 줄여 주어 대부분의 가상 DOM 오버헤드를 피할 수 있다.</li>\n<li>두번째로, 컴파일러는 정적 노드, 서브트리, 데이터 객체 등을 적극적으로 감지하여 렌더 함수 바깥으로 hoist 한다. 이렇게 하면 각 렌더링마다 객체들을 다시 생성하지 않아도 되므로 메모리 효율을 크게 높일 수 있고, 가비지 콜렉션의 빈도가 줄어들게 된다.</li>\n<li>마지막으로, DOM element 레벨에서 컴파일러는 수행해야 하는 업데이트 유형에 따라 동적 바인딩이 있는 각 element에 대한 최적화 플래그를 생성한다. 예를 들어 동적 클래스 바인딩과 여러 개의 정적 속성을 가진 element는 클래스 검사만 필요하다는 플래그를 받는 식이다. 런타임은 이러한 힌트를 보고 더 빠른 업데이트 경로를 판단하게 된다.</li>\n</ul>\n<p>벤치마크 시 Vue 3의 CPU Time<em>(브라우저의 DOM 조작을 제외한 JavaScript 연산에 소요된 시간)</em>은 Vue 2의 1/10도 안 걸릴 때가 종종 있을만큼 이러한 기술들을 통해 렌더 성능이 크게 개선되었음을 확인했다.</p>\n<h3 id=\"번들-크기-최소화\"><a href=\"#%EB%B2%88%EB%93%A4-%ED%81%AC%EA%B8%B0-%EC%B5%9C%EC%86%8C%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>번들 크기 최소화</h3>\n<p>프레임워크의 사이즈도 성능에 영향을 미친다. 이는 웹 애플리케이션에 국한된 문제인데, 브라우저가 필요한 asset들을 전부 다운로드 받고 JavaScript를 파싱할 때까지 애플리케이션이 반응하지 않기 때문이다. 특히 SPA의 경우 이러한 경향이 더욱 두드러진다. Vue는 Vue 2의 gzip으로 압축된 런타임 크기가 23KB일만큼 상대적으로 경량화된 크기라고 볼 수 있지만, 우리는 다음과 같은 문제들을 발견했다.</p>\n<ul>\n<li>첫째로, 모든 사용자가 Vue의 모든 기능들을 사용하는 것은 아니다. 예를 들어 transition 기능을 사용하지 않는 애플리케이션도 의도와 상관없이 무조건 transition 관련 코드의 다운로드와 파싱을 수행해야 한다.</li>\n<li>두번째는 우리가 기능을 추가할 때마다 프레임워크의 크기 역시 계속 커진다는 것이다. 우리가 새로운 기능을 추가하려 할 때마다 번들 크기를 고려하지 않을 수 없고, 결과적으로 대다수의 사용자가 사용할만한 기능만 포함하게 되는 경향이 있다.</li>\n</ul>\n<p>결국 <a href=\"https://en.wikipedia.org/wiki/Tree_shaking\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tree-shaking</a>이라고 부르는 사용하지 않는 코드를 빌드 타임에 제거할 수 있는 기능을 지원해야 하며, 사용자가 포함한 기능만 번들에 포함되어야 한다. 이렇게 되면 우리가 유용하다고 생각하는 기능들도 부담없이 추가하여 제공할 수 있게 된다.</p>\n<p>Vue 3에서는 대부분의 전역 API와 내부 헬퍼들을 ES 모듈로 변경하여 번들러가 사용하지 않는 모듈과 관련된 종속성 및 코드들을 제거할 수 있도록 지원한다. 템플릿 컴파일러도 실제로 템플릿에서 사용되는 기능만 import 한 다음 코드를 생성하여 번들러가 tree-shaking을 할 수 있도록 구현했다.</p>\n<p>하지만 일부는 Vue를 사용하는 모든 유형의 애플리케이션에 필수적이기 때문에 tree-shaking을 지원할 수 없다. 우리는 이런 필수불가결한 부분의 크기를 baseline size라고 부르는데, Vue 3의 baseline size는 수많은 기능이 추가되었음에도 Vue 2의 절반보다도 작은 10KB 정도이다.</p>\n<hr>\n<h1 id=\"대규모-애플리케이션-지원에-대한-필요성\"><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%A7%80%EC%9B%90%EC%97%90-%EB%8C%80%ED%95%9C-%ED%95%84%EC%9A%94%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대규모 애플리케이션 지원에 대한 필요성</h1>\n<p>우리는 Vue가 대규모 애플리케이션을 다루기 위해 더 개선되길 원했다. 우리가 처음 Vue를 설계할 때는 진입장벽을 낮추고 더 배우기 쉽게 하는데 초점을 맞췄었다. 하지만 Vue가 점점 널리 쓰이면서 수백 개의 모듈을 포함하고, 수십명의 개발자가 관리하는 프로젝트의 요구사항들을 알게 되었다. 이정도 규모의 프로젝트는 TypeScript와 같은 타입 시스템과 재사용 가능한 코드를 깔끔하게 관리하는 기능이 중요하며 이러한 측면에서 Vue는 썩 좋지는 않았다.</p>\n<p>Vue 3 설계 초기 단계에는 클래스를 사용한 컴포넌트 구현을 빌트인으로 지원하여 Vue에서의 TypeScript 사용성을 개선하려고 시도했다. 문제는 이를 구현하기 위해 필요한 클래스 필드나 데코레이터 등이 여전히 proposal 상태라 JavaScript에 공식적으로 포함되기 전에 어떻게 변할지 장담할 수 없다는 것이었다. 클래스 API의 추가는 다소 개선된 TypeScript와의 통합 지원 외의 어떠한 것도 제공하지 않았기 때문에, 이러한 불확실성과 구현의 복잡도를 고려하면 과연 이 방법이 맞는 것인지 의문을 가질 수 밖에 없었다.</p>\n<p>결국 우리는 다른 방법을 찾기로 결정했다. React의 <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a>에서 영감을 받아 하위 레벨의 반응성과 컴포넌트의 lifecycle API를 밖으로 드러내어 좀 더 자유롭게 컴포넌트 구현이 가능하도록 <a href=\"https://vue-composition-api-rfc.netlify.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Composition API</a>라 부르는 방법을 생각해냈다. 이는 길게 option API를 나열하여 컴포넌트를 정의하는 대신, 사용자가 마치 함수를 작성하듯이 자유롭게 상태 기반 로직을 작성하고 재사용할 수 있으며, 우수한 TypeScript 지원을 제공한다.</p>\n<p>우리는 이 아이디어에 매우 흥분했다. 비록 composition API는 특정 문제를 해결하기 위해 설계되었지만 기술적으로는 컴포넌트를 구현할 때 사용될 수 있다. 너무 고취한 나머지 proposal의 첫번째 초안에서 조금 이른감은 있지만 향후 릴리즈에서 기존 option API를 composition API로 바꿀 수 있다고 암시했다. 이는 커뮤니티의 엄청난 반발을 불러왔고, 이로부터 장기적인 계획과 의도를 명확하게 전달하고 사용자의 요구사항을 충분히 이해해야 한다는 귀중한 교훈을 얻었다. 커뮤니티로부터 피드백을 받은 후, proposal을 완전히 재작성하여 composition API가 option API에 부가적이고 보완적인 기능이라는 점을 분명히 했다. 수정된 proposal의 반응은 훨씬 긍정적이어서 많은 건설적인 제안을 받았다.</p>\n<hr>\n<h1 id=\"균형-추구\"><a href=\"#%EA%B7%A0%ED%98%95-%EC%B6%94%EA%B5%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>균형 추구</h1>\n<p>백만명이 넘는 Vue 개발자 중에는 HTML/CSS에 대한 기초 지식만 있는 초보자들, jQuery에서 넘어온 전문가들, 다른 프레임워크에서 마이그레이션을 한 베테랑들, 프론트엔드 솔루션을 찾는 백엔드 엔지니어들, 대규모로 소프트웨어를 다루는 아키텍트 등 다양한 사용자들이 있다. 이러한 만큼 그에 맞는 다양한 사용 사례에 대한 대응이 필요하다. 어떤 개발자는 기존 애플리케이션에 간단한 상호작용 정도만 보수적으로 도입하고자 하는 반면, 다른 개발자는 유지보수 걱정이 덜한 일회성 프로젝트에서 다양한 기능들을 실험해볼 수도 있다. 아키텍트는 수년동안 대규모 프로젝트와 개발팀을 이끌어야 할 것이다.</p>\n<p>Vue의 구조는 이런 다양한 trade-offs 사이에서 균형을 유지하기 위해 지속적으로 다듬어지고 있다. Vue의 슬로건인 <strong>'The progressive framework'</strong>는 이러한 과정에서 비롯되는 계층화된 API 디자인을 캡슐화함을 뜻한다. 덕분에 초보자는 CDN, HTML 기반 템플릿, 직관적인 option API 등을 통해 원활하게 학습할 수 있고, 전문가는 완전한 기능을 갖춘 CLI, 렌더 함수, compsition API 등을 통해 그들에 맞는 다양한 사례를 처리할 수 있다.</p>\n<p>이러한 우리의 비전을 Vue 3에서 실현하기 위해 해야할 일이 아직도 많이 남아있다. 가장 중요한 것은 원활한 마이그레이션을 위해 지원 라이브러리, 문서 및 도구들을 업데이트하는 것이다. 이를 위해 향후 몇 개월동안 열심히 일할 것이며, Vue 3를 통해 사용자들이 어떤 것들을 만들어낼지 무척이나 기대된다.</p>\n"}},{"node":{"title":"[번역] await vs return vs return await","path":"/await-vs-return-vs-return-await/","date":"4. March 2020","timeToRead":2,"description":"async 함수를 작성할 때 사용하는 await, return, return await 각각의 차이점을 알아본다.","content":"<blockquote>\n<p>Jake Archibald의 <a href=\"https://jakearchibald.com/2017/await-vs-return-vs-return-await/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">await vs return vs return await</a> 번역글입니다. 굳이 이 글이 아니더라도 모든 번역글은 역자의 의도와 상관없이 원문의 내용과 다르게 전달될 수 있으니 원문도 같이 보시는 걸 권해드립니다.</p>\n</blockquote>\n<p>async 함수를 작성할 때 사용하는 <code>await</code>, <code>return</code>, <code>return await</code>의 차이점을 알고, 올바른 선택을 하는 것이 중요하다. 아래 예제를 보자.</p>\n<pre><code>async function waitAndMaybeReject() {\n  // Wait one second\n  await new Promise(r => setTimeout(r, 1000));\n\n  // Toss a coin\n  const isHeads = Boolean(Math.round(Math.random()));\n\n  if (isHeads) return 'yay';\n  throw Error('Boo!');\n}\n</code></pre>\n<p>이 함수는 반반의 확률로 Fulfilled(이행) 상태가 되어 'yay'를 던져주거나 Rejected(실패) 상태가 되어 에러를 던지는 promise를 반환한다. 이걸 몇 가지 다른 방식으로 사용해보자.</p>\n<hr>\n<h2 id=\"just-calling\"><a href=\"#just-calling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Just calling</h2>\n<pre><code>async function foo() {\n  try {\n    waitAndMaybeReject();\n  }\n  catch (e) {\n    return 'caught';\n  }\n}\n</code></pre>\n<p>위와 같이 <code>foo</code>를 호출하면 항상 <strong>undefined인 Fulfilled 상태의 promise를 곧바로 리턴</strong>할 것이다. <code>waitAndMaybeReject()</code>를 await 하거나 리턴하지 않았기 때문이다.</p>\n<h2 id=\"awaiting\"><a href=\"#awaiting\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Awaiting</h2>\n<pre><code>async function foo() {\n  try {\n    await waitAndMaybeReject();\n  }\n  catch (e) {\n    return 'caught';\n  }\n}\n</code></pre>\n<p><code>foo</code>를 호출하면 이번엔 <strong>항상 1초를 기다린 뒤 undefined나 'caught'인 Fulfilled 상태의 promise</strong>를 리턴할 것이다. 위 코드에서 <code>waitAndMaybeReject()</code>를 await 하기 때문에 해당 함수가 Rejected 상태의 promise를 리턴하면 catch 블록이 실행되어 'caught'를 리턴하지만, Fulfilled 상태의 promise를 리턴하면 여전히 await만 할 뿐 아무 동작을 하지 않기 때문에 yay를 얻을 수 없다.</p>\n<h2 id=\"returning\"><a href=\"#returning\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Returning</h2>\n<pre><code>async function foo() {\n  try {\n    return waitAndMaybeReject();\n  }\n  catch (e) {\n    return 'caught';\n  }\n}\n</code></pre>\n<p><code>foo</code>를 호출하면 <strong>항상 1초를 기다린 뒤, 'yay'를 가진 Fulfilled 상태나 Error('Boo!')를 throw하는 Rejected 상태의 promise</strong>를 리턴할 것이다. <code>waitAndMaybeReject()</code>를 await 하지 않고 바로 리턴하기 때문에 catch 블록은 절대 실행되지 않는다.</p>\n<h2 id=\"return-awaiting\"><a href=\"#return-awaiting\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Return-awaiting</h2>\n<pre><code>async function foo() {\n  try {\n    return await waitAndMaybeReject();\n  }\n  catch (e) {\n    return 'caught';\n  }\n}\n</code></pre>\n<p><code>foo</code>를 호출하면 <strong>항상 1초를 기다린 뒤, 'yay'나 'caught'를 가진 Fulfilled 상태의 promise</strong>를 리턴할 것이다. <code>waitAndMaybeReject()</code>를 await 했기 때문에 해당 함수가 Rejected 상태의 promise를 리턴하면 catch 블록이 실행되어 'caught'를 리턴하고, Fulfilled 상태이면 'yay'를 리턴한다.</p>\n<hr>\n<p>위의 내용들이 혼란스러우면 아래와 같이 두 단계로 생각하면 좀 더 쉬울 것이다.</p>\n<pre><code>async function foo() {\n  try {\n    // waitAndMaybeReject()의 결과가 정해질 때까지 기다린 후,\n    // 그 값을 fulfilledValue에 할당\n    const fulfilledValue = await waitAndMaybeReject();\n\n    // 그리고 fulfilledValue를 리턴\n    return fulfilledValue;\n  }\n  catch (e) {\n    // 만약 waitAndMaybeReject()가 Rejected 상태면\n    // catch 블록이 실행되기 때문에 'caught'를 리턴\n    return 'caught';\n  }\n}\n</code></pre>\n<p><a href=\"https://github.com/eslint/eslint/blob/master/docs/rules/no-return-await.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Note</a>: async 함수의 리턴값은 항상 Promise.resolve로 wrapped 되어 있기 때문에 return await는 실효성이 없다. 다만 try/catch 구문에서는 다른 Promise 함수의 오류를 catch 하기 위해 사용될 수 있다.</p>\n"}}]}}},"context":{}}